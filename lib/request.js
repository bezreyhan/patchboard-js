// Generated by CoffeeScript 1.9.3
(function() {
  var EventEmitter, Request, Response, ResponseContent, URL, corsetCase, error, http, https, zlib,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  http = require("http");

  https = require("https");

  URL = require("url");

  try {
    zlib = require("zlib");
  } catch (_error) {
    error = _error;
    zlib = null;
  }

  EventEmitter = require("events").EventEmitter;

  corsetCase = function(string) {
    return string.toLowerCase().replace("_", "-").replace(/(^|-)(\w)/g, function(s) {
      return s.toUpperCase();
    });
  };

  module.exports = Request = (function(superClass) {
    extend(Request, superClass);

    function Request(options, handler) {
      var callback, client, hostname, parameters, path, port, protocol, raw, ref, timeout;
      this.url = options.url, this.method = options.method, this.headers = options.headers, this.body = options.body, timeout = options.timeout, this.redirects = options.redirects;
      if (this.headers == null) {
        this.headers = {};
      }
      this.method = this.method.toUpperCase();
      if (this.redirects == null) {
        this.redirects = 1;
      }
      ref = URL.parse(this.url), protocol = ref.protocol, hostname = ref.hostname, port = ref.port, path = ref.path;
      if (protocol === "http:") {
        client = http;
        if (port == null) {
          port = 80;
        }
      } else {
        client = https;
        if (port == null) {
          port = 443;
        }
      }
      parameters = {
        host: hostname,
        port: port,
        path: path,
        method: this.method,
        headers: this.headers,
        protocol: protocol,
        withCredentials: false
      };
      if ((this.body != null) && (typeof Buffer !== "undefined" && Buffer !== null)) {
        this.headers["Content-Length"] = Buffer.byteLength(this.body);
      }
      callback = (function(_this) {
        return function(error, response) {
          if (handler != null) {
            handler(error, response);
          }
          if (error != null) {
            return _this.emit("error", error);
          } else {
            return _this.emit("success", response);
          }
        };
      })(this);
      raw = client.request(parameters, (function(_this) {
        return function(response) {
          switch (response.statusCode) {
            case 300:
            case 301:
            case 302:
            case 303:
            case 307:
              return _this.redirect(_this, response, callback);
            case 304:
            case 305:
              return callback(new Error(response.statusCode + " handling not yet implemented"));
            default:
              return response = new Response(response, callback);
          }
        };
      })(this));
      raw.on("error", (function(_this) {
        return function(error) {
          return callback(error);
        };
      })(this));
      if (timeout != null) {
        raw.setTimeout(timeout, (function(_this) {
          return function() {
            return raw.abort();
          };
        })(this));
      }
      if (this.body != null) {
        raw.write(this.body.toString());
      }
      raw.end();
    }

    Request.prototype.redirect = function(request, response, callback) {
      var body, headers, location, method, redirects, timeout;
      method = request.method, headers = request.headers, body = request.body, timeout = request.timeout, redirects = request.redirects;
      if (!(method === "GET" || method === "HEAD")) {
        return callback(new Error("Received redirect for method other than GET or HEAD"));
      } else if (redirects === 0) {
        return callback(new Error("Exceeded allowed number of redirects"));
      } else {
        location = response.headers["Location"] || response.headers["location"];
        if (location != null) {
          return new Request({
            url: location,
            redirects: redirects - 1,
            method: method,
            headers: headers,
            body: body,
            timeout: timeout
          }, callback);
        } else {
          return callback(new Error("Redirect response did not provide Location"));
        }
      }
    };

    return Request;

  })(EventEmitter);

  Response = (function() {
    function Response(raw1, callback) {
      var key, ref, value;
      this.raw = raw1;
      this._content = new ResponseContent(this);
      this.status = this.raw.statusCode;
      this.headers = {};
      this._normalized = {};
      ref = this.raw.headers;
      for (key in ref) {
        value = ref[key];
        this.headers[key] = value;
        this._normalized[corsetCase(key)] = value;
      }
      this.raw.on("end", (function(_this) {
        return function() {
          return _this._content.process(function(content) {
            _this.content = content;
            _this.body = _this.content.body;
            _this.data = _this.content.data;
            return callback(null, _this);
          });
        };
      })(this));
    }

    Response.prototype.getHeader = function(name) {
      return this.headers[name] || this._normalized[corsetCase(name)];
    };

    return Response;

  })();

  ResponseContent = (function() {
    function ResponseContent(response1) {
      var encoding, headers;
      this.response = response1;
      this.raw = this.response.raw;
      this.chunks = [];
      this.length = 0;
      headers = this.raw.headers;
      this.type = headers["Content-Type"] || headers["content-type"];
      switch ((encoding = headers["Content-Encoding"] || headers["content-encoding"])) {
        case "gzip":
          this.encoding = encoding;
          break;
        default:
          this.encoding = null;
      }
      this.raw.on("data", (function(_this) {
        return function(chunk) {
          _this.chunks.push(chunk);
          return _this.length += chunk.length;
        };
      })(this));
    }

    ResponseContent.prototype.process = function(callback) {
      this.buffer = this.chunks.join("");
      return this.process_encoding((function(_this) {
        return function() {
          return _this.process_type(callback);
        };
      })(this));
    };

    ResponseContent.prototype.process_encoding = function(callback) {
      if ((this.encoding != null) && (zlib != null)) {
        return zlib.gunzip(this.buffer, (function(_this) {
          return function(error, buffer) {
            _this.body = buffer.toString("utf-8");
            return callback();
          };
        })(this));
      } else {
        this.body = this.buffer.toString("utf-8");
        return callback();
      }
    };

    ResponseContent.prototype.process_type = function(callback) {
      if (this.type != null) {
        if (/json/.test(this.type)) {
          try {
            this.data = JSON.parse(this.body);
          } catch (_error) {
            error = _error;
            this.data = void 0;
          }
        }
      }
      return callback({
        buffer: this.buffer,
        body: this.body,
        data: this.data
      });
    };

    return ResponseContent;

  })();

}).call(this);
